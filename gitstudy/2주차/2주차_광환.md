# Chapter 3 차원 넘나들기

## Lesson 09 여러 브랜치 만들어보기

---

### 깃에서 브랜치가 필요한 경우

1. 하나의 프로젝트를 여러 형태로 사용해야 할 때
2. 현업에서 여러 개발자가 역할을 분담해서 프로그래밍을 할 때

### 몰랐던 브랜치 명령어

```
git switch -c new-branch
-> 브랜치 새로 생성하고 new-branch라고 이름붙이기
```

# Lesson 10 브랜치를 합치는 두가지 방법

---

1. merge
   - 작업내역 남기고 브랜치를 합병함
   - main 브랜치로 이동한 다음 대상 브랜치를 합침
2. rebase
   - 작업내역 남기지 않고 대상 브랜치에 이어붙임
   - 대상 브랜치로 이동한 다음 main브랜치를 합침 -> 어느 브랜치를 가장 앞의 커밋으로 할 건지에 따라 어느 브랜치에서 명령을 내리는 지 결정

# Lesson 11 브랜치 간 충돌 해결하기

### 머지 충돌 해결하기

- 두 브랜치의 같은 줄에 다른 내용이 있을 경우 충돌 발생!
- (다른 내용이 들어가 있지 않고 내용이 추가된 경우 충돌이 발생하지 않는다.)
- git merge branch-name으로 충돌을 낸 다음 변경사항을 검토하고 저장 후 커밋하기
- git commit명령어를 통해 커밋을 실행하면 자동으로 깃에서 커밋메세지를 적어준다.

### 리베이스 충돌 해결하기

- 머지는 브랜치에서 충돌하는 파일만 수정해서 하나의 커밋으로 해결했지만 리베이스는 합칠 브랜치 안에 있는 모든 커밋마다 충돌을 하나씩 차례로 해결해주어야 한다.
- 1. `git add .`으로 변경사항 추적하기
- 2. `git rebase --continue`로 다음 커밋으로 넘어가기
- 3. 모든 커밋의 충돌을 해결하고 `main`브랜치에서 `merge`명령어 실행
- 4. 필요없는 브랜치 삭제(브랜치를 삭제할 경우 브랜치는 없어지지만 merge를 통해 분기된 모든 커밋은 남는다.)

# Chapter 4 깃허브 사용하기

---

## lesson 14 푸시와 풀

### 풀할 것이 있는데 푸시한다면?

> 로컬 깃 저장소가 원격저장소보다 작업 내역이 뒤처져 있는 경우 git push명령을 실행하면 오류가 발생한다.

#### 머지 방식으로 병합

```
git pull --no-rebase
```

#### 리베이스 방식으로 병합

```
git pull --rebase
```

-> 컨플릭트가 날 때 당황하지 말고 명령어 기억하기!

## Lesson 15 원격 저장소의 브랜치 다루기

1. 원격 저장소에 브랜치 만들기

```
$ git push --set-upstream origin from-local
```

2. 모든 저장소의 브랜치 확인
   ```
   git branch --all
   ```
3. 원격저장소의 브랜치를 로컬에서 풀하기

   ```
   브랜치를 받아오기
   git fetch

   브랜치의 모든 커밋을 받아오기
   git switch -t origin/from-remote

   ```

4. 원격저장소의 브랜치 삭제하기
   ```
   git push origin --delete from-remote
   ```

## Lesson 17 깃의 특징과 기능의 기술적 이해

### 깃이 특별한 이유

> 1. 버전관리에 스냅샷방식을 사용한다.
> 2. 분산버전관리 시스템이다.

#### 델타방식과 스냅샷 방식

1. 델타방식

   ![alt text](image.png)<br>
   파일이 수정되면 변경점들이 저장되는 방식

2. 스냅샷 방식

   ![alt text](image-1.png)<br>
   새로운 버전이 만들어질 때 해당 버전의 각 파일이 최종상태 그대로 저장되는 방식

#### 두 방식의 차이

컴퓨터 내부적으로 파일추적을 계산하는 방식이 다르며 스냅샷 방식이 더 효율적이다.<br>
델타방식 : 각 파일이 처음 만들어진 시점부터변경사항을 하나한 다 더해서 현재내용을 계산해 내야 하므로 관리내역이 길어질수록 느려진다.

#### 분산버전관리 시스템

원격저장소를 필두로 함께 작업하는 모든 사람의 컴퓨터에 각각의 버전이 다 존재한다. <br>
때문에 중심이 되는 원격저장소에 문제가 생겨도 델타방식에 비해 문제해결이 용이하다(하지만 그렇게 쉽지는 않다.)

### 깃의 세가지 공간 작업디렉터리, 스테이지 영역, 저장소

깃은 다음과 같은 흐름으로 파일이 이동한다.

1. 저장소 : 커밋이 저장되어 어떤 버전안에 들어있는 공간
2. 작업디렉터리 : 저장소에서 어떤 작업을 해서 파일이 수정될 경우 작업디렉토리에 위치한다. 파일이 작업 디렉토리에 위치하면 두가지 상태가 있다.
3. 스테이지 영역 : 커밋하여 저장소에 들어가기 전 준비상태
   - tracked - 깃이 관리하는 상태(git cli로 지지고 볶고 할 수 있는 상태)
   - untracked - .gitignore파일에 추가되었거나 아직 add하지 않아서 버전관리가 안되고 있는 상태

### git rm 명령으로 파일 삭제하면서 바로 커밋하기

git rm = 삭제 + git add <br>
아래 명령으로 삭제되었다는 변경사항을 스테이지 영역에 넘겨서 바로 커밋이 가능하다.

```
git rm tiger.yaml


On branch main
Your branch is up to date with 'origin/main'.

Changes to be committed:
  (use "git restore --staged <file>..." to unstage)
        deleted:    tigers.yaml
```

명령어를 실행하면 위와 같이 스테이지에 파일이 올라갔응음 알 수 있다.

```
git reset --hard  // 가장 마지막 커밋으로 돌아간다.
```

위 명령어로 스테이지된 사항을 번복할 수 있다. 하지만 이 경우 모든 파일을 다 변경해야 하는 경우가 생긴다. 마지막 커밋으로 돌아가는 것이 아닌 파일을 스테이지에서 내리려면 어떻게 해야 할까 바로 이때 restore를 사용한다.

#### git restore

`--staged` 옵션을 주면 스테이징된 파일을 스테이지에서 끌어내린다. 이때 스테이징된 파일에 대해서 `git restore pumas.yaml`만 입력할 경우 아무런 동작도 수행하지 않는다.

```
$ git restore --staged pumas.yaml
```

스테이지에서 파일을 끌어내린 이후 아래의 코드로 변경사항까지 전부 되돌리기가 가능하다.

```
$ git restore pumas.yaml
```

이제 스테이지에서 끌어내리는 법을 배웠으니 작업을 되돌리는 방법을 배워보자

#### git reset

1. `git reset --hard` : 수정사항을 완전히 되돌림, 변경사항을 작업디렉터리에서도 없앰
2. `git reset --mixed` : 변경사항을 스테이지영역에서만 제거됨 그러면 restore랑 차이가 뭐누 -> restore는 하나의 파일에서만 해당하는 거인듯?
