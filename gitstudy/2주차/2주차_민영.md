# Chaper05. 깃을 더 깊게 이해하기

## Lesson17. 깃의 특징과 기능의 기술적 이해
깃은 파일의 스냅샷을 저장하여 변화를 관리하고, 중앙 서버에 의존하지 않고 로컬에서 자유롭게 작업할 수있는 분산 버전 관리 시스템  
작업 디렉터리에서 파일을 추가, 변경, 삭제하고, 스테이지 영역에서 커밋하여 저장소에 버전을 저장   
이를 통해 각자 작업하며 협업할 수 있음.

### 깃이 특별한 이유

첫째. 스냅샷을 사용
델타방식은 파일이 수정되면 그 변경점들이 저장되는 방식입니다.
스냅샷방식은 새로운 버전이 만들어질떄 해당 버전의 각 파일의 최종상태 그대로 저장되는 방식입니다.
어떤 변경사항이 발생하건 간에 델타방식은 각파일이 처음 만들어진 시점부터 변경사항들을 하나하나 다 더해서 현재 내용을 계산해 내야하므로 관리내역이 길수록 느려짐
반면에 스냅샷 방식은 현 시점의 파일이 저장되어있으니까 최종 결과물을 훨씬 더 빨리 확인할 수 있음.

둘째. 깃은 분산 버전 관리 시스템
깃은 중앙집중식 버전관리가 아닌 분산버전 관리 시스템
원격 저장소에 의존하는 방식은 중앙서버 또는 인터넷연결에 문제가 생기면 로컬에서 작업하는데 제한이 생김
반면 깃은 원격 저장소에서 전체 깃 커밋과 브랜치까지 받아 로컬에서 자유롭게 작업이 가능함
모든 구성원이 자신의 컴퓨터에 깃의 작업내역들을 모두 갖고 있기 때문에 각자 편한대로 작업하다가 원하는 때에 프로젝트를 푸시와 풀로 동기화하면서 협업을 할 수 있음.

### 깃의 세가지 공간: 작업 디렉토리,스테이지 영역, 저장소
깃에서는 파일의 상태를 작업 디렉터리,스테이지 영역,저장소 등 세가지로 분류함.

이미 커밋이 저장되어 어떤 버전 안에 들어있는 공간을 저장소(리포지토리)라고 함.
새로 파일이 추가되거나 기존 파일이 변경되거나 삭제되는 등 수정사항이 생기면 작업 디첵터리에 위치
작업 디렉터리는 tracked와 untracked라는 두가지 상태로 나뉨
tracked는 깃의 관리대상에 정식으로 등록되는 것.
untracked는 .gitignore파일에 추가되어있어서 깃이 무시하는 파일 혹은 프로젝트 폴더에 새로 만들었지만 아직 관리되어 본 적이 없는 파일 ,즉 git add명령을 적용하지 않는 파일.
- tracked:깃의 관리대상에 정식으로 등록된 파일
- untracked: 깃이 무시하는 파일 혹은 아직 관리되어 본적이 없는 파일

Untracked files는 깃이 관리해 본적이 없는 파일, 즉 add된적이 없는 파일을 의미
git add 명령을 적용하면 스테이지 영역으로 이동.  ->스테이지 영역은 저장소에 들어가기 전 준비 단계라고 보면됨.
git commit명령을 실행하면 저장소의 커밋상태로 옮김. 이때 파일이 커밋되는 저장소를 .git directory라고 부르기도함.
파일을 새로 만들거나 수정하면 다시 작업 디렉터리로 들어감.

### git rm명령으로 파일 삭제하기
파일 삭제후 git status명령으로 상태 확인  

<img width="398" alt="스크린샷 2024-06-27 173136" src="https://github.com/nyeongha/systudy1/assets/49603260/abb2987c-a460-436a-9062-6566c7680856">

삭제 내역을 커밋해서 버전에 저장하려면 git add .명령을 실행해야함.
다시 git status명령을 실행하면 삭제한 파일이 deleted로 처리되는것을 확인할 수있음.

<img width="383" alt="스크린샷 2024-06-27 23 03 59" src="https://github.com/nyeongha/systudy1/assets/49603260/04b94bf6-616c-43b1-91d0-84f4fd38a833">

git reset --hard명령으로 앞의 작업을 되돌림.

<img width="421" alt="스크린샷 2024-06-27 23 06 02" src="https://github.com/nyeongha/systudy1/assets/49603260/52ed8a61-6f42-49c0-a324-dbf6d894dd4a">

### git rm명령으로 파일 삭제하면서 바로 커밋하기

1.git rm명령을 사용하면 어떤 파일을 삭제하면서 동시에 삭제되었다는 변경사항ㅇ을 스테이지 영역에 넘겨서 바로 커밋할 수있음.
> git rm (파일 이름)
<img width="435" alt="스크린샷 2024-06-27 23 08 38" src="https://github.com/nyeongha/systudy1/assets/49603260/17282c39-2e87-4b62-bc91-786d4bc71a46">

2.git status명령으로 상태확인. git commit명령으로 깃 메시지를 입력하고 실행ㅎ면 변경사항이 바로 저장소에 커밋됨.
<img width="393" alt="스크린샷 2024-06-27 23 10 01" src="https://github.com/nyeongha/systudy1/assets/49603260/b456e897-d14b-4c8c-aa80-4e8fb7c86d2a">

3.git reset명령으로 작업 되돌리기
<img width="421" alt="스크린샷 2024-06-27 23 10 52" src="https://github.com/nyeongha/systudy1/assets/49603260/62a05209-bd46-4027-b6f1-a221b30c1edd">


### git mv명령으로 파일 이동하기

1.파일 이름 변경

2.git status명령으로 상태 확인-두가지 변화가 나타남.-->기존파일 삭제와 새 파일 생성
<img width="504" alt="스크린샷 2024-06-27 23 13 26" src="https://github.com/nyeongha/systudy1/assets/49603260/fc12ff67-7b25-4e54-a520-da4451c16356">

3.git add .명령을 적용하고, 다시 git status명령을 실행함.->파일이름이 변경된 것이라고 깃이 제대로 인식
<img width="397" alt="스크린샷 2024-06-27 23 14 38" src="https://github.com/nyeongha/systudy1/assets/49603260/1a4b1206-25ca-403b-bf48-83e5bf30bc04">

4.git reset명령으로 앞의 작업 되돌리기

### git mv명령으로 파일이름 변경하기
> git mv (원래 파일 이름) (변경 파일 이름)

1.git mv명령을 실행하고, git status명령을 입력하면 이름이 바뀌어 수정사항이 스테이지 영역에 올라간것을 확인 할수 있음.즉, 커밋할 준비가 된것임.

<img width="546" alt="스크린샷 2024-06-27 23 18 28" src="https://github.com/nyeongha/systudy1/assets/49603260/e0e68b3f-5462-4b21-885c-a5f0a13007cf">

2.git reset --hard명령으로 변경사항 되돌림.
<img width="425" alt="스크린샷 2024-06-27 23 19 47" src="https://github.com/nyeongha/systudy1/assets/49603260/48a55f6d-61c5-4fe8-a74c-2e062d67c50b">

### restore명령으로 파일을 작업 디렉터리로 되돌리기
1. 여러 파일 내용 변경
<img width="375" alt="스크린샷 2024-06-27 23 23 54" src="https://github.com/nyeongha/systudy1/assets/49603260/847c8d31-b323-4fe1-a5fa-300705717484">

2.이 중 커밋에 포함하고싶지 않은 파일을 스테이지 영역에서 빼고 작업 디렉터리로 옮김. git status명령을 실행
> git restore --staged (파일이름)
> git status
<img width="538" alt="스크린샷 2024-06-27 23 26 30" src="https://github.com/nyeongha/systudy1/assets/49603260/46120aba-fd91-495b-a643-689ad1210958">

>> 소스트리에서 실행하는 간단한 방법: history에서 커밋하지 않은 변경사항을 선택하면 파일 상태를 확인할 수 있음.
>> +를 통해 다시 스테이지로 올릴 수 있고, 스테이지에 있는 파일도 -를 클릭하면 내릴 수 있음.
<img width="1035" alt="스크린샷 2024-06-27 23 29 58" src="https://github.com/nyeongha/systudy1/assets/49603260/9f9cd407-4ba4-4397-876d-acb4a2baf0d9">  

3.아예 변경 사항을 작업 디렉터리에서 빼려면 git restore명령을 적용하면된다.
즉, git restore --staged는 스테이지 영역에서 작업 디렉터리(파일이 수정되어 저장만 된 상태)로 되돌리는 것이고,   
add가 되지 않은 작업 디렉터리에 있는 파일을 restore하면 수정하기 이전의 커밋 상태로 되돌림  

### git reset명령으로 작업 되돌리기

- git reset --hard: 작업 내역 자체를 지움
- git reset --mixed: 변경사항을 스테이지 영역에서만 제거, reset명령의 기본값이라 옵션을 입력하지않고 git reset만 입력해도 동일하게 적용됨.
- git reset --soft: 변경사항을 저장소에서만 제거하고 스테이지 영역으로 남겨둠. add만 된상태로 두는 것

1. 파일에 내용을 추가하고 저장후 커밋
<img width="496" alt="스크린샷 2024-06-27 23 37 36" src="https://github.com/nyeongha/systudy1/assets/49603260/6a0ab1d9-c70d-4ca6-841e-3a6fd5d30d99">

2. 바로 앞단계의 시점으로 리셋하기
   - 앞단계의 커밋을 선택
   - 앞단계의 해시값복사
3. 해당 파일을 보면 변경된 부분이 그대로 남아있지만, git status명령으로 확인하면 add되기전 작업 디렉터리로 돌아가있는 것을 알수있음.
   <img width="506" alt="스크린샷 2024-06-27 23 41 47" src="https://github.com/nyeongha/systudy1/assets/49603260/002dfcb4-3daf-4fca-983d-c22bc44fbbae">

4. --soft옵션을 적용해 바로 앞단계의 커밋으로 되돌리기
> git reset --soft (복사한 커밋 해시값)
git status명령으로 상태를 확인하면 변경사항이 아직 지워지지않았고, 스테이지에 add되어있는 상태라는 뜻  


## Lesson18. 체크아웃과 페치
### 헤드 개념 이해하기
깃에서 헤드는 현재 작업중인 브랜치의 가장 최신 커밋을 나타내는 포인터-->특정 브랜치의 최신 커밋  
깃에서는 여러 브랜치를 생성하여 작업을 진행. 각브랜치는 서로 다른 커밋을 가짐. 헤드는 작업중인 브랜치를 가리키고있으며, 그 브랜치에서 가장 마지막 커밋임  
체크아웃 명령을 이용하면 헤드를 이동해서 이전 커밋으로 돌아가는 등의 작업을 수행할 수 있음.  

헤드는 다음과 같은 상황에서 바뀔수있음  
1.새로운 커밋이 작업중인 브랜치에 추가될 때마다 해당 커밋을 가리킴  
2.새로운 브랜치를 생성할때 헤드가 새로운 브랜치를 가리킴  
3.다른 브랜치로 이동할때 헤드가 이동한 브랜치를 가리킴  













