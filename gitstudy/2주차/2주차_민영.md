# Chaper05. 깃을 더 깊게 이해하기

## Lesson17. 깃의 특징과 기능의 기술적 이해
깃은 파일의 스냅샷을 저장하여 변화를 관리하고, 중앙 서버에 의존하지 않고 로컬에서 자유롭게 작업할 수있는 분산 버전 관리 시스템  
작업 디렉터리에서 파일을 추가, 변경, 삭제하고, 스테이지 영역에서 커밋하여 저장소에 버전을 저장   
이를 통해 각자 작업하며 협업할 수 있음.

### 깃이 특별한 이유

첫째. 스냅샷을 사용
델타방식은 파일이 수정되면 그 변경점들이 저장되는 방식입니다.
스냅샷방식은 새로운 버전이 만들어질떄 해당 버전의 각 파일의 최종상태 그대로 저장되는 방식입니다.
어떤 변경사항이 발생하건 간에 델타방식은 각파일이 처음 만들어진 시점부터 변경사항들을 하나하나 다 더해서 현재 내용을 계산해 내야하므로 관리내역이 길수록 느려짐
반면에 스냅샷 방식은 현 시점의 파일이 저장되어있으니까 최종 결과물을 훨씬 더 빨리 확인할 수 있음.

둘째. 깃은 분산 버전 관리 시스템
깃은 중앙집중식 버전관리가 아닌 분산버전 관리 시스템
원격 저장소에 의존하는 방식은 중앙서버 또는 인터넷연결에 문제가 생기면 로컬에서 작업하는데 제한이 생김
반면 깃은 원격 저장소에서 전체 깃 커밋과 브랜치까지 받아 로컬에서 자유롭게 작업이 가능함
모든 구성원이 자신의 컴퓨터에 깃의 작업내역들을 모두 갖고 있기 때문에 각자 편한대로 작업하다가 원하는 때에 프로젝트를 푸시와 풀로 동기화하면서 협업을 할 수 있음.

### 깃의 세가지 공간: 작업 디렉토리,스테이지 영역, 저장소
깃에서는 파일의 상태를 작업 디렉터리,스테이지 영역,저장소 등 세가지로 분류함.

이미 커밋이 저장되어 어떤 버전 안에 들어있는 공간을 저장소(리포지토리)라고 함.
새로 파일이 추가되거나 기존 파일이 변경되거나 삭제되는 등 수정사항이 생기면 작업 디첵터리에 위치
작업 디렉터리는 tracked와 untracked라는 두가지 상태로 나뉨
tracked는 깃의 관리대상에 정식으로 등록되는 것.
untracked는 .gitignore파일에 추가되어있어서 깃이 무시하는 파일 혹은 프로젝트 폴더에 새로 만들었지만 아직 관리되어 본 적이 없는 파일 ,즉 git add명령을 적용하지 않는 파일.
- tracked:깃의 관리대상에 정식으로 등록된 파일
- untracked: 깃이 무시하는 파일 혹은 아직 관리되어 본적이 없는 파일

Untracked files는 깃이 관리해 본적이 없는 파일, 즉 add된적이 없는 파일을 의미
git add 명령을 적용하면 스테이지 영역으로 이동.  ->스테이지 영역은 저장소에 들어가기 전 준비 단계라고 보면됨.
git commit명령을 실행하면 저장소의 커밋상태로 옮김. 이때 파일이 커밋되는 저장소를 .git directory라고 부르기도함.
파일을 새로 만들거나 수정하면 다시 작업 디렉터리로 들어감.

### git rm명령으로 파일 삭제하기
파일 삭제후 git status명령으로 상태 확인  

<img width="398" alt="스크린샷 2024-06-27 173136" src="https://github.com/nyeongha/systudy1/assets/49603260/abb2987c-a460-436a-9062-6566c7680856">

삭제 내역을 커밋해서 버전에 저장하려면 git add .명령을 실행해야함.
다시 git status명령을 실행하면 삭제한 파일이 deleted로 처리되는것을 확인할 수있음.  

<img width="383" alt="스크린샷 2024-06-27 23 03 59" src="https://github.com/nyeongha/systudy1/assets/49603260/04b94bf6-616c-43b1-91d0-84f4fd38a833">

git reset --hard명령으로 앞의 작업을 되돌림.  

<img width="421" alt="스크린샷 2024-06-27 23 06 02" src="https://github.com/nyeongha/systudy1/assets/49603260/52ed8a61-6f42-49c0-a324-dbf6d894dd4a">

### git rm명령으로 파일 삭제하면서 바로 커밋하기

1.git rm명령을 사용하면 어떤 파일을 삭제하면서 동시에 삭제되었다는 변경사항ㅇ을 스테이지 영역에 넘겨서 바로 커밋할 수있음.
> git rm (파일 이름)
  
<img width="435" alt="스크린샷 2024-06-27 23 08 38" src="https://github.com/nyeongha/systudy1/assets/49603260/17282c39-2e87-4b62-bc91-786d4bc71a46">

2.git status명령으로 상태확인. git commit명령으로 깃 메시지를 입력하고 실행하면 변경사항이 바로 저장소에 커밋됨.  
<img width="393" alt="스크린샷 2024-06-27 23 10 01" src="https://github.com/nyeongha/systudy1/assets/49603260/b456e897-d14b-4c8c-aa80-4e8fb7c86d2a">

3.git reset명령으로 작업 되돌리기  
<img width="421" alt="스크린샷 2024-06-27 23 10 52" src="https://github.com/nyeongha/systudy1/assets/49603260/62a05209-bd46-4027-b6f1-a221b30c1edd">


### git mv명령으로 파일 이동하기

1.파일 이름 변경

2.git status명령으로 상태 확인-두가지 변화가 나타남.-->기존파일 삭제와 새 파일 생성  
<img width="504" alt="스크린샷 2024-06-27 23 13 26" src="https://github.com/nyeongha/systudy1/assets/49603260/fc12ff67-7b25-4e54-a520-da4451c16356">

3.git add .명령을 적용하고, 다시 git status명령을 실행함.->파일이름이 변경된 것이라고 깃이 제대로 인식  
<img width="397" alt="스크린샷 2024-06-27 23 14 38" src="https://github.com/nyeongha/systudy1/assets/49603260/1a4b1206-25ca-403b-bf48-83e5bf30bc04">

4.git reset명령으로 앞의 작업 되돌리기

### git mv명령으로 파일이름 변경하기
> git mv (원래 파일 이름) (변경 파일 이름)

1.git mv명령을 실행하고, git status명령을 입력하면 이름이 바뀌어 수정사항이 스테이지 영역에 올라간것을 확인 할수 있음.즉, 커밋할 준비가 된것임.  

<img width="546" alt="스크린샷 2024-06-27 23 18 28" src="https://github.com/nyeongha/systudy1/assets/49603260/e0e68b3f-5462-4b21-885c-a5f0a13007cf">

2.git reset --hard명령으로 변경사항 되돌림.  
<img width="425" alt="스크린샷 2024-06-27 23 19 47" src="https://github.com/nyeongha/systudy1/assets/49603260/48a55f6d-61c5-4fe8-a74c-2e062d67c50b">

### restore명령으로 파일을 작업 디렉터리로 되돌리기  
1. 여러 파일 내용 변경  
<img width="375" alt="스크린샷 2024-06-27 23 23 54" src="https://github.com/nyeongha/systudy1/assets/49603260/847c8d31-b323-4fe1-a5fa-300705717484">

2.이 중 커밋에 포함하고싶지 않은 파일을 스테이지 영역에서 빼고 작업 디렉터리로 옮김. git status명령을 실행
> git restore --staged (파일이름)
> git status

<img width="538" alt="스크린샷 2024-06-27 23 26 30" src="https://github.com/nyeongha/systudy1/assets/49603260/46120aba-fd91-495b-a643-689ad1210958">

>> 소스트리에서 실행하는 간단한 방법: history에서 커밋하지 않은 변경사항을 선택하면 파일 상태를 확인할 수 있음.
>> +를 통해 다시 스테이지로 올릴 수 있고, 스테이지에 있는 파일도 -를 클릭하면 내릴 수 있음.

<img width="1035" alt="스크린샷 2024-06-27 23 29 58" src="https://github.com/nyeongha/systudy1/assets/49603260/9f9cd407-4ba4-4397-876d-acb4a2baf0d9">  

3.아예 변경 사항을 작업 디렉터리에서 빼려면 git restore명령을 적용하면된다.
즉, git restore --staged는 스테이지 영역에서 작업 디렉터리(파일이 수정되어 저장만 된 상태)로 되돌리는 것이고,   
add가 되지 않은 작업 디렉터리에 있는 파일을 restore하면 수정하기 이전의 커밋 상태로 되돌림  

### git reset명령으로 작업 되돌리기

- git reset --hard: 작업 내역 자체를 지움
- git reset --mixed: 변경사항을 스테이지 영역에서만 제거, reset명령의 기본값이라 옵션을 입력하지않고 git reset만 입력해도 동일하게 적용됨.
- git reset --soft: 변경사항을 저장소에서만 제거하고 스테이지 영역으로 남겨둠. add만 된상태로 두는 것

1. 파일에 내용을 추가하고 저장후 커밋  
<img width="496" alt="스크린샷 2024-06-27 23 37 36" src="https://github.com/nyeongha/systudy1/assets/49603260/6a0ab1d9-c70d-4ca6-841e-3a6fd5d30d99">

2. 바로 앞단계의 시점으로 리셋하기
   - 앞단계의 커밋을 선택
   - 앞단계의 해시값복사
3. 해당 파일을 보면 변경된 부분이 그대로 남아있지만, git status명령으로 확인하면 add되기전 작업 디렉터리로 돌아가있는 것을 알수있음.  
   <img width="506" alt="스크린샷 2024-06-27 23 41 47" src="https://github.com/nyeongha/systudy1/assets/49603260/002dfcb4-3daf-4fca-983d-c22bc44fbbae">

4. --soft옵션을 적용해 바로 앞단계의 커밋으로 되돌리기
> git reset --soft (복사한 커밋 해시값)
git status명령으로 상태를 확인하면 변경사항이 아직 지워지지않았고, 스테이지에 add되어있는 상태라는 뜻  


## Lesson18. 체크아웃과 페치
### 헤드 개념 이해하기
깃에서 헤드는 현재 작업중인 브랜치의 가장 최신 커밋을 나타내는 포인터-->특정 브랜치의 최신 커밋,해당 브랜치의 마지막 커밋
깃에서는 여러 브랜치를 생성하여 작업을 진행. 각브랜치는 서로 다른 커밋을 가짐. 헤드는 작업중인 브랜치를 가리키고있으며, 그 브랜치에서 가장 마지막 커밋임  
체크아웃 명령을 이용하면 헤드를 이동해서 이전 커밋으로 돌아가는 등의 작업을 수행할 수 있음.  

헤드는 다음과 같은 상황에서 바뀔수있음  
1.새로운 커밋이 작업중인 브랜치에 추가될 때마다 해당 커밋을 가리킴  
2.새로운 브랜치를 생성할때 헤드가 새로운 브랜치를 가리킴  
3.다른 브랜치로 이동할때 헤드가 이동한 브랜치를 가리킴  

### 체크아웃

체크아웃은 작업내역을 그대로 두고 파일의 상태만 과거시점으로 이동할 때 사용.
체크아웃으로 한단계만큼 돌아가려면 다음과같은 명령을 작성
> git checkout HEAD^
이때 HEAD뒤에 붙이는 ^(캐럿)의 갯수만큼 뒷 단계로 이동이 가능
^(캐럿)대신 ~(물결선)을 사용할수도있고 ~(물결선)뒤에 단계 갯수를 써도 됨.

세단계 전으로 이동하려면 다음과 같이 작성
> git checkout HEAD^^^
> git checkout HEAD~3

checkout은 reset과 revert와는 다름
reset은 한단계뒤로 가면서 앞단계를 지워버리지만 checkout은 파일들의 상태만 한 단계뒤 시점으로 되돌리는 것.

뒤로 이동한 단계를 다시 한단계 앞으로 돌리려면 git checkout명령뒤에 -(하이픈)을 붙임.
> git checkout -

### git checkout명령으로 헤드이동하고 소스트리에서 확인하기
git checkout명령어 다음에 커밋 해시값을 붙여도 해당위치로 체크아웃할 수있음.
1. 현재헤드는 delta-branch맨끝에 있음. 두단계전으로 헤드를 이동
> git checkout HEAD^^
delta-branch의 헤드가 두단계 이전으로 이동한 것을 확인할 수 있음.  
> <img width="272" alt="스크린샷 2024-06-28 00 38 36" src="https://github.com/nyeongha/systudy1/assets/49603260/21babfb5-4fcb-4ab1-96d3-4d7eefe032ba">

3.한단계 뒤로 더 이동함. delta-branch가 main브랜치에서 갈라지기 전 시점으로 이동.  
<img width="312" alt="스크린샷 2024-06-28 00 42 45" src="https://github.com/nyeongha/systudy1/assets/49603260/5d21bbc6-becf-427d-b058-13a2097a3760">

4.앞으로 이동한 위치에서 한단계 앞으로 되돌리려면 git checkout -(하이픈)명령을 이용  
<img width="298" alt="스크린샷 2024-06-28 00 44 31" src="https://github.com/nyeongha/systudy1/assets/49603260/1f01f0b7-6f1f-4cc0-98fd-8495b3a53c1a">

5.현재 브랜치 확인
main이나 delta-branch가 아닌 이전에 없던 임의의 브랜치로 지정
checkout으로 과거로 돌아간다는 것은 해당시점에 아직 이름이 지어지지않은 임시 브랜치를 생성한 뒤 그쪽으로 이동하는 것.  
<img width="421" alt="스크린샷 2024-06-28 00 46 49" src="https://github.com/nyeongha/systudy1/assets/49603260/8e77a8a4-a9cb-436d-8b29-31c22c6b945e">

6.다시 delta-branch의 끝으로 돌아가려면 git switch 명령으로 브랜치를 이동  
<img width="311" alt="스크린샷 2024-06-28 00 47 46" src="https://github.com/nyeongha/systudy1/assets/49603260/5eb30feb-d3de-419d-8de3-9d5e4096b66e">

7. 다른 브랜치로 이동해서 전단계로 헤드를 이동후 새브랜치로 분기->새로 분기한 브랜치에 커밋을 하나 만들기->소스트리를 확인해보면 beta-branch에서 gamma-branch가 한줄기뻗어나온것을 볼수있음
이런식으로 체크아웃을 사용해서 커밋을 앞뒤로 왓다갔다 이동하고 거기서 또다른 브랜치를 생성할 수 있음.  
<img width="355" alt="스크린샷 2024-06-28 00 52 45" src="https://github.com/nyeongha/systudy1/assets/49603260/62764380-cb2b-4d42-8f86-b6249ed54b95">

### 헤드를 사용하여 리셋하기
해드를 사용하면 리셋을 더 편리하게 할 수있음
> git reset (옵션) HEAD~원하는 단계

### 페치와 풀의 차이
풀은 원격 저장소의 최신 커밋을 로컬 컴퓨터로 가져와 머지하거나 리베이스함.
페치는 원격 저장소의 최신 커밋을 로컬로 가져오기만 함.

**변경사항을 페치해서 미리 확인하기**
페치를 하면 로컬에 가상의 브랜치가 하나 추가되고 변경사항을 받아옴.

1.main브랜치에서 git fetch명령을 실행
로컬에 커밋을 반영하지않더라도 원격저장소의 프로젝트 파일을 로컬에서 한벌 실행해보기 위해 git checkout명령을 사용
> git checkout origin/main
변경사항을 확인후 코드에 문제가없다고 판단되면 main브랜치로 풀을 할수있음.
> git switch main
> git pull

**원격 저장소에 있는 내용을 페치하고 체크아웃으로 전체폴더의 상태를 확인할 수있다.**

### 원격 저장소의 새 브랜치 확인하기
깃허브 원격 저장소에서 브랜치 생성후 vscode로 돌아와 git fetch를 하면 새브랜치가 나타남
이번에도 이 브랜치를 다운로드 하지않고 일단 확인만해보기 위해서는 새브랜치를 체크아웃함
> git checkout origin/새브랜치
문제가 없다면 main으로 돌아와 git switch명령을 이용. 그러면 로컬에서도 새브랜치가 생기고, 원격 origin/new-branch와 연결되어 계속 커밋을 주고받을 수 있음.
> git switch -t origin/new-branch

## 도움말과 설정 활용하기
### git help명령으로 도움말 활용

git help를 입력하면 깃 명령어와 그에 대한 간략한 설명을 살펴볼 수 있음.-->번거롭고 급한 상황에서 유용
깃의 모든 명령어를 보고싶다면 git help -a를 입력
출력 결과가 길다면 j로 내리고 k로 올리면서 모든 명령어를 스크롤해서 볼수 있음
q를 입력해 출력결과를 종료

특정 명령뒤에어떤 옵션을 붙일 수 있는 지 cli에서 바로 찾고싶다면 해당명령을 입력하고 -h를 입력
ex) git commit -h

명령과 옵션을 웹사이트에서 자세히 보고싶다면 git help다음에 명령어를 입력하거나 git 다음에 특정 명령어를 입력하고 --help옵션을 붙임
그러면 깃의 커밋에 대한 설명과 옵션을 웹사이트에서 바로 열어볼 수 있음.
> git help (명령어)
> git (명령어) --help

### 깃 문서 참고하기
깃에대해 자세히 체계적으로 알고싶으면 깃 웹사이트의 documentation항목에서 다양한 메뉴를 살펴볼 수 있음.
https://git-scm.com/docs
pro Git이라는 책도 Pdf로 다운가능

### 깃의 각종 설정
git config는 깃의 작동을 변경할 수 있음.
-global설정은 해당 컴퓨터의 깃에서 사용하는 모든 저장소에 대한 설정을 변경
-local설정은 특정 깃 저장소에 대해서만 설정을 변경

### 설정값 확인하기

> git config --list

global설정만 보려녀 --global을 붙여야함
> git config --global --list

cli터미널에서 열리는 출력 결과를 vim에디터에서 열어보고싶다면 git config명령뒤에 -e를 붙임
> git config -e
> git config --global -e

vim으로 결과를 확인하는게 불편하다면 기본 에디터를 vscode가되도록 설정을 변경.
code는 vscode를 말하고, --wait은 에디터에서 코드를 수정하는 동안 cli를 정지한다는 뜻
> git config --global core.editor "code --wait"

맥에서 code로 vscode가 실행되지않을때
cmd+shift+P를 누르고 shell로 검색하여 셸명령:PATH에 code명령 설치를 선택

에디터 설정 되돌리기
git config --global -e명령으로 편집기를 연뒤 
[core]editor "code --wait"을 삭제하고 파일을 저장하면 됨.

### 줄바꿈 호환 문제 해결

윈도우와 맥은 enter/return을 눌러서 줄바꿈하는 방식이 서로 다름
윈도우를 쓰는 사람과 맥을 쓰는 사람이 협업할떄 코드는 바뀌지 않았는데 줄바꿈을 읽는 방식이 달라서 수정된 것으로 잘못 인식하는 경우가 생길 수있음.이러한 문제를 해결하기위해 다음과 같이 설정

윈도우의 경우
> git config --global core.autocrlf true

맥의 경우
> git config --global core.autocrlf input

### git pull명령의 기본값 지정
다음 명령에서 flase옵션을 하면 머지가 기본값이되고,true옵션을 지정하면 리베이스가 기본값이 됨.
> git config pull.rebase false
> git config pull.rebase true


### 기본 브랜치 이름 지정하기
기본 브랜치이름은 보통 main으로 하지만 ,trunk로 정하는 사람도 있음.
> git config --global init.defaultBranch main

### 푸시할때 로컬과 동일한 브랜치 이름 적용하기
깃에서 처음 푸시할때 git push명령뒤에 -u 혹은 -upstream옵션을 붙임
현재 로컬 브랜치를 원격의 어느 브랜치와 연결할지 처음에 설정하는 것

로컬의 main브랜치에서 git push 명령을 적용하면 자동으로 원격의 main브랜치로 푸시되도록 지정
예외사항이 있다면 그떄만 명시적으로 지정
> git config --global push.default current

### 단축키 설정
원하는 명령어를 "(큰따음표)안에 입력하고 alias. 다음에 단축키를 입력
> git config --global alias.(단축키) "명령어"

Ex) commit -am명령을 일일이 입력하는 대신 cam만 입력해도 동일한 명령어가 실행
> git config --global alias.cam "commit -am"





